"""
Back-pressure & Budget Protection Middleware

This module provides comprehensive budget monitoring, rate limiting, and circuit breaker
functionality to protect against runaway API costs and cascading failures. It integrates
with the provider registry and Prometheus metrics for real-time monitoring.

Features:
- Real-time budget tracking per provider
- Rate limiting with sliding windows
- Circuit breaker patterns for failing providers
- Alert triggers for budget overages
- Graceful request rejection when limits hit
- Integration with OpenTelemetry tracing

Usage:
    # Add to FastAPI app
    app.add_middleware(BackpressureMiddleware)
    
    # Environment variables
    BUDGET_ALERT_THRESHOLD=0.8  # Alert at 80% of budget
    BUDGET_ENFORCE_LIMITS=true  # Reject requests over budget
    CIRCUIT_BREAKER_ENABLED=true

Generated by Factory Droid on 2025-06-28 following "cook & push to GitHub" motto
"""

import asyncio
import logging
import os
import time
from collections import defaultdict, deque
from contextlib import asynccontextmanager
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Dict, List, Optional, Set, Tuple
from urllib.parse import urlparse

from fastapi import HTTPException, Request, Response, status
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import JSONResponse

try:
    from backend.core.metrics import ApiMetrics
    from backend.core.redis_client import RedisClient, RedisDb
    from backend.core.telemetry import add_span_attribute, get_current_span
    from backend.providers import get_providers_by_category
except ImportError:
    # Fallback for development/testing
    ApiMetrics = None
    RedisClient = None
    get_providers_by_category = lambda x: []

# Configure logging
logger = logging.getLogger(__name__)

class CircuitState(Enum):
    """Circuit breaker states."""
    CLOSED = "closed"      # Normal operation
    OPEN = "open"          # Circuit breaker triggered, rejecting requests
    HALF_OPEN = "half_open"  # Testing if service has recovered

@dataclass
class ProviderLimits:
    """Provider-specific limits and thresholds."""
    provider_id: str
    daily_budget_usd: float = 0.0
    monthly_budget_usd: float = 0.0
    requests_per_minute: int = 100
    requests_per_day: int = 10000
    circuit_breaker_threshold: int = 5  # Failed requests before circuit opens
    circuit_breaker_timeout: int = 60   # Seconds to wait before trying again
    alert_threshold: float = 0.8        # Alert at 80% of budget

@dataclass
class BudgetTracker:
    """Real-time budget tracking for a provider."""
    provider_id: str
    daily_spend_usd: float = 0.0
    monthly_spend_usd: float = 0.0
    daily_requests: int = 0
    monthly_requests: int = 0
    last_reset_day: datetime = field(default_factory=datetime.now)
    last_reset_month: datetime = field(default_factory=datetime.now)
    requests_this_minute: deque = field(default_factory=lambda: deque(maxlen=60))
    
    def reset_if_needed(self) -> None:
        """Reset counters if day/month boundaries crossed."""
        now = datetime.now()
        
        # Reset daily counters
        if now.date() > self.last_reset_day.date():
            self.daily_spend_usd = 0.0
            self.daily_requests = 0
            self.last_reset_day = now
            logger.info(f"Reset daily counters for provider: {self.provider_id}")
        
        # Reset monthly counters
        if now.month != self.last_reset_month.month or now.year != self.last_reset_month.year:
            self.monthly_spend_usd = 0.0
            self.monthly_requests = 0
            self.last_reset_month = now
            logger.info(f"Reset monthly counters for provider: {self.provider_id}")

@dataclass
class CircuitBreaker:
    """Circuit breaker for provider health monitoring."""
    provider_id: str
    state: CircuitState = CircuitState.CLOSED
    failure_count: int = 0
    last_failure_time: Optional[datetime] = None
    success_count: int = 0
    failure_threshold: int = 5
    recovery_timeout: int = 60
    half_open_max_attempts: int = 3
    
    def record_success(self) -> None:
        """Record a successful request."""
        if self.state == CircuitState.HALF_OPEN:
            self.success_count += 1
            if self.success_count >= self.half_open_max_attempts:
                self._close_circuit()
        elif self.state == CircuitState.CLOSED:
            self.failure_count = max(0, self.failure_count - 1)  # Gradual recovery
    
    def record_failure(self) -> None:
        """Record a failed request."""
        self.failure_count += 1
        self.last_failure_time = datetime.now()
        
        if self.state == CircuitState.CLOSED and self.failure_count >= self.failure_threshold:
            self._open_circuit()
        elif self.state == CircuitState.HALF_OPEN:
            self._open_circuit()
    
    def can_request(self) -> bool:
        """Check if requests are allowed through the circuit."""
        if self.state == CircuitState.CLOSED:
            return True
        elif self.state == CircuitState.OPEN:
            return self._should_attempt_reset()
        elif self.state == CircuitState.HALF_OPEN:
            return True
        return False
    
    def _open_circuit(self) -> None:
        """Open the circuit breaker."""
        self.state = CircuitState.OPEN
        self.success_count = 0
        logger.warning(f"Circuit breaker OPENED for provider: {self.provider_id}")
    
    def _close_circuit(self) -> None:
        """Close the circuit breaker."""
        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.success_count = 0
        logger.info(f"Circuit breaker CLOSED for provider: {self.provider_id}")
    
    def _should_attempt_reset(self) -> bool:
        """Check if enough time has passed to attempt reset."""
        if not self.last_failure_time:
            return True
        
        time_since_failure = (datetime.now() - self.last_failure_time).total_seconds()
        if time_since_failure >= self.recovery_timeout:
            self.state = CircuitState.HALF_OPEN
            self.success_count = 0
            logger.info(f"Circuit breaker entering HALF_OPEN for provider: {self.provider_id}")
            return True
        
        return False

class BackpressureManager:
    """Manages budget tracking, rate limiting, and circuit breakers."""
    
    def __init__(self):
        self.provider_limits: Dict[str, ProviderLimits] = {}
        self.budget_trackers: Dict[str, BudgetTracker] = {}
        self.circuit_breakers: Dict[str, CircuitBreaker] = {}
        self.redis_client: Optional[RedisClient] = None
        self.enabled = os.getenv("BUDGET_ENFORCE_LIMITS", "true").lower() == "true"
        self.alert_threshold = float(os.getenv("BUDGET_ALERT_THRESHOLD", "0.8"))
        self.circuit_breaker_enabled = os.getenv("CIRCUIT_BREAKER_ENABLED", "true").lower() == "true"
        
        # Initialize from provider registry
        self._load_provider_limits()
        self._initialize_redis()
        
        # Start metrics updater task
        self.start_metrics_updater()
    
    def _load_provider_limits(self) -> None:
        """Load provider limits from registry."""
        try:
            providers = get_providers_by_category("api") or []
            for provider in providers:
                provider_id = provider.get("id")
                if not provider_id:
                    continue
                
                budget = provider.get("budget", {})
                rate_limits = provider.get("rate_limits", {})
                
                limits = ProviderLimits(
                    provider_id=provider_id,
                    daily_budget_usd=budget.get("daily_usd", 0.0),
                    monthly_budget_usd=budget.get("monthly_usd", 0.0),
                    requests_per_minute=rate_limits.get("requests_per_minute", 100),
                    requests_per_day=rate_limits.get("requests_per_day", 10000),
                )
                
                self.provider_limits[provider_id] = limits
                self.budget_trackers[provider_id] = BudgetTracker(provider_id=provider_id)
                self.circuit_breakers[provider_id] = CircuitBreaker(provider_id=provider_id)
                
                logger.info(f"Loaded limits for provider: {provider_id}")
        
        except Exception as e:
            logger.error(f"Error loading provider limits: {e}")
    
    def _initialize_redis(self) -> None:
        """Initialize Redis client for distributed state."""
        try:
            if RedisClient:
                self.redis_client = RedisClient(db=RedisDb.CACHE)
        except Exception as e:
            logger.warning(f"Redis not available for backpressure state: {e}")
    
    async def check_request_allowed(self, provider_id: str, request_cost_usd: float = 0.0) -> Tuple[bool, str]:
        """
        Check if a request is allowed based on budget and rate limits.
        
        Args:
            provider_id: Provider identifier
            request_cost_usd: Estimated cost of the request
            
        Returns:
            (allowed, reason) tuple
        """
        if not self.enabled:
            return True, "backpressure_disabled"
        
        if provider_id not in self.provider_limits:
            logger.warning(f"Unknown provider: {provider_id}")
            return True, "unknown_provider"
        
        limits = self.provider_limits[provider_id]
        tracker = self.budget_trackers[provider_id]
        circuit_breaker = self.circuit_breakers[provider_id]
        
        # Reset counters if needed
        tracker.reset_if_needed()
        
        # Check circuit breaker
        if self.circuit_breaker_enabled and not circuit_breaker.can_request():
            return False, f"circuit_breaker_open"
        
        # Check budget limits
        if limits.daily_budget_usd > 0:
            if tracker.daily_spend_usd + request_cost_usd > limits.daily_budget_usd:
                return False, f"daily_budget_exceeded"
        
        if limits.monthly_budget_usd > 0:
            if tracker.monthly_spend_usd + request_cost_usd > limits.monthly_budget_usd:
                return False, f"monthly_budget_exceeded"
        
        # Check rate limits
        now = time.time()
        
        # Requests per minute check
        minute_window = [t for t in tracker.requests_this_minute if now - t < 60]
        if len(minute_window) >= limits.requests_per_minute:
            return False, f"rate_limit_per_minute_exceeded"
        
        # Requests per day check
        if tracker.daily_requests >= limits.requests_per_day:
            return False, f"daily_request_limit_exceeded"
        
        return True, "allowed"
    
    async def record_request(self, provider_id: str, cost_usd: float = 0.0, success: bool = True) -> None:
        """Record a completed request for tracking."""
        if provider_id not in self.budget_trackers:
            return
        
        tracker = self.budget_trackers[provider_id]
        circuit_breaker = self.circuit_breakers[provider_id]
        
        # Update budget tracking
        tracker.daily_spend_usd += cost_usd
        tracker.monthly_spend_usd += cost_usd
        tracker.daily_requests += 1
        tracker.monthly_requests += 1
        tracker.requests_this_minute.append(time.time())
        
        # Update circuit breaker
        if self.circuit_breaker_enabled:
            if success:
                circuit_breaker.record_success()
            else:
                circuit_breaker.record_failure()
        
        # Check for alerts
        await self._check_budget_alerts(provider_id)
        
        # Update metrics
        if ApiMetrics:
            ApiMetrics.track_call(
                provider=provider_id,
                endpoint="budget_tracking",
                status="success" if success else "error",
                response_time=0.0,
                environment=os.getenv("ENVIRONMENT", "development"),
                version=os.getenv("APP_VERSION", "1.9.0-beta")
            )
    
    async def _check_budget_alerts(self, provider_id: str) -> None:
        """Check if budget alerts should be triggered."""
        limits = self.provider_limits.get(provider_id)
        tracker = self.budget_trackers.get(provider_id)
        
        if not limits or not tracker:
            return
        
        # Daily budget alert
        if limits.daily_budget_usd > 0:
            usage_ratio = tracker.daily_spend_usd / limits.daily_budget_usd
            if usage_ratio >= self.alert_threshold:
                logger.warning(
                    f"Budget alert: {provider_id} daily usage at {usage_ratio:.1%} "
                    f"(${tracker.daily_spend_usd:.2f} / ${limits.daily_budget_usd:.2f})"
                )
        
        # Monthly budget alert
        if limits.monthly_budget_usd > 0:
            usage_ratio = tracker.monthly_spend_usd / limits.monthly_budget_usd
            if usage_ratio >= self.alert_threshold:
                logger.warning(
                    f"Budget alert: {provider_id} monthly usage at {usage_ratio:.1%} "
                    f"(${tracker.monthly_spend_usd:.2f} / ${limits.monthly_budget_usd:.2f})"
                )
    
    def get_provider_status(self, provider_id: str) -> Dict[str, Any]:
        """Get current status for a provider."""
        if provider_id not in self.provider_limits:
            return {"error": "provider_not_found"}
        
        limits = self.provider_limits[provider_id]
        tracker = self.budget_trackers[provider_id]
        circuit_breaker = self.circuit_breakers[provider_id]
        
        tracker.reset_if_needed()
        
        return {
            "provider_id": provider_id,
            "budget": {
                "daily_spent_usd": tracker.daily_spend_usd,
                "daily_limit_usd": limits.daily_budget_usd,
                "monthly_spent_usd": tracker.monthly_spend_usd,
                "monthly_limit_usd": limits.monthly_budget_usd,
            },
            "requests": {
                "daily_count": tracker.daily_requests,
                "daily_limit": limits.requests_per_day,
                "requests_this_minute": len([t for t in tracker.requests_this_minute if time.time() - t < 60]),
                "minute_limit": limits.requests_per_minute,
            },
            "circuit_breaker": {
                "state": circuit_breaker.state.value,
                "failure_count": circuit_breaker.failure_count,
                "can_request": circuit_breaker.can_request(),
            }
        }
    
    def update_metrics(self) -> None:
        """Update Prometheus metrics with current provider status."""
        if not ApiMetrics:
            return
        
        try:
            # Get status for all providers
            all_providers_status = {
                provider_id: self.get_provider_status(provider_id)
                for provider_id in self.provider_limits.keys()
            }
            
            # Update metrics
            ApiMetrics.update_all_providers_metrics(all_providers_status)
            logger.debug("Updated provider metrics in Prometheus")
        except Exception as e:
            logger.error(f"Error updating provider metrics: {e}")
    
    async def _metrics_updater_task(self) -> None:
        """Background task to periodically update metrics."""
        while True:
            try:
                self.update_metrics()
            except Exception as e:
                logger.error(f"Error in metrics updater task: {e}")
            
            # Update every 15 seconds
            await asyncio.sleep(15)
    
    def start_metrics_updater(self) -> None:
        """Start the background metrics updater task."""
        if not ApiMetrics:
            logger.warning("ApiMetrics not available, metrics updater not started")
            return
        
        # Start background task
        asyncio.create_task(self._metrics_updater_task())
        logger.info("Started provider metrics updater task")

# Global manager instance
_backpressure_manager: Optional[BackpressureManager] = None

def get_backpressure_manager() -> BackpressureManager:
    """Get the global backpressure manager instance."""
    global _backpressure_manager
    if _backpressure_manager is None:
        _backpressure_manager = BackpressureManager()
    return _backpressure_manager

class BackpressureMiddleware(BaseHTTPMiddleware):
    """FastAPI middleware for budget and rate limiting."""
    
    def __init__(self, app):
        super().__init__(app)
        self.manager = get_backpressure_manager()
        self.excluded_paths = {
            "/health", "/metrics", "/docs", "/redoc", "/openapi.json",
            "/api/v1/health", "/api/v1/auth"
        }
    
    async def dispatch(self, request: Request, call_next) -> Response:
        """Process request through backpressure checks."""
        # Skip middleware for excluded paths
        if request.url.path in self.excluded_paths:
            return await call_next(request)
        
        # Detect provider from request
        provider_id = self._detect_provider_from_request(request)
        if not provider_id:
            # Non-provider request, pass through
            return await call_next(request)
        
        # Add tracing attributes
        span = get_current_span()
        if span:
            add_span_attribute("backpressure.provider", provider_id)
            add_span_attribute("backpressure.enabled", self.manager.enabled)
        
        # Check if request is allowed
        allowed, reason = await self.manager.check_request_allowed(provider_id, request_cost_usd=0.001)
        
        if not allowed:
            logger.warning(f"Request blocked for {provider_id}: {reason}")
            
            if span:
                add_span_attribute("backpressure.blocked", True)
                add_span_attribute("backpressure.reason", reason)
            
            return JSONResponse(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                content={
                    "error": "request_blocked_by_backpressure",
                    "provider": provider_id,
                    "reason": reason,
                    "retry_after": self._get_retry_after(provider_id, reason)
                }
            )
        
        # Process request
        start_time = time.time()
        try:
            response = await call_next(request)
            success = 200 <= response.status_code < 400
            
            # Record request completion
            await self.manager.record_request(
                provider_id=provider_id,
                cost_usd=0.001,  # Estimated cost
                success=success
            )
            
            if span:
                add_span_attribute("backpressure.recorded", True)
                add_span_attribute("backpressure.success", success)
            
            return response
            
        except Exception as e:
            # Record failed request
            await self.manager.record_request(
                provider_id=provider_id,
                cost_usd=0.001,
                success=False
            )
            
            if span:
                add_span_attribute("backpressure.recorded", True)
                add_span_attribute("backpressure.success", False)
                add_span_attribute("backpressure.error", str(e))
            
            raise
    
    def _detect_provider_from_request(self, request: Request) -> Optional[str]:
        """Detect which provider this request is targeting."""
        # Check URL patterns
        path = request.url.path.lower()
        
        # API tool endpoints
        if "/api/v1/tools" in path:
            # Extract tool name from URL or request body
            if "sim" in path:
                return "sim"
            elif "covalent" in path:
                return "covalent"
            elif "moralis" in path:
                return "moralis"
        
        # Chat/crew endpoints that might trigger external calls
        if "/api/v1/chat" in path or "/api/v1/crew" in path:
            # These might trigger multiple providers, use a general rate limit
            return "general"
        
        return None
    
    def _get_retry_after(self, provider_id: str, reason: str) -> int:
        """Get retry-after seconds based on the blocking reason."""
        if "circuit_breaker" in reason:
            return 60
        elif "rate_limit" in reason:
            return 60
        elif "budget" in reason:
            return 3600  # 1 hour for budget issues
        return 300  # 5 minutes default

# Utility functions for direct usage

async def check_provider_budget(provider_id: str, cost_usd: float = 0.0) -> bool:
    """Check if a provider request is within budget limits."""
    manager = get_backpressure_manager()
    allowed, _ = await manager.check_request_allowed(provider_id, cost_usd)
    return allowed

async def record_provider_usage(provider_id: str, cost_usd: float = 0.0, success: bool = True) -> None:
    """Record provider usage for budget tracking."""
    manager = get_backpressure_manager()
    await manager.record_request(provider_id, cost_usd, success)

def get_provider_status(provider_id: str) -> Dict[str, Any]:
    """Get current budget and rate limit status for a provider."""
    manager = get_backpressure_manager()
    return manager.get_provider_status(provider_id)

def get_all_provider_status() -> Dict[str, Any]:
    """Get status for all configured providers."""
    manager = get_backpressure_manager()
    return {
        provider_id: manager.get_provider_status(provider_id)
        for provider_id in manager.provider_limits.keys()
    }
