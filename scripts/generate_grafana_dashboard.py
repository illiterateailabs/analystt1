#!/usr/bin/env python3
"""
Grafana Dashboard Generator for External API Cost & Rate Limit Monitoring

This script automatically generates comprehensive Grafana dashboards for monitoring
external API providers including cost tracking, rate limiting, and performance metrics.
It reads the provider registry and creates tailored dashboards for each provider.

Usage:
    python scripts/generate_grafana_dashboard.py
    python scripts/generate_grafana_dashboard.py --provider sim
    python scripts/generate_grafana_dashboard.py --output custom_dashboard.json
    python scripts/generate_grafana_dashboard.py --template cost-focused

Features:
    - Auto-discovers providers from registry.yaml
    - Generates cost burn rate panels
    - Rate limit monitoring & alerting
    - API performance & error tracking
    - Ready-to-import Grafana JSON
    - Supports multiple dashboard templates

Generated by Factory Droid on 2025-06-28 following "cook & push to GitHub" motto
"""

import argparse
import json
import logging
import os
import sys
import time
from datetime import datetime, timedelta
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

import yaml

# Add backend to sys.path to allow imports
sys.path.insert(0, str(Path(__file__).resolve().parent.parent))

try:
    from backend.providers import get_providers_by_category
except ImportError:
    # Fallback if provider loading fails
    get_providers_by_category = None

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Dashboard templates
DASHBOARD_TEMPLATES = {
    "comprehensive": "Full monitoring with cost, performance, and rate limits",
    "cost-focused": "Cost tracking and budget management only",
    "performance": "API performance and error monitoring",
    "rate-limits": "Rate limit monitoring and alerting"
}

class GrafanaDashboardGenerator:
    """Generates Grafana dashboards for external API monitoring."""

    def __init__(self):
        self.dashboard_id = int(time.time())
        self.panel_id_counter = 1

    def generate_dashboard(
        self,
        providers: List[Dict[str, Any]],
        template: str = "comprehensive",
        title_suffix: str = ""
    ) -> Dict[str, Any]:
        """Generate a complete Grafana dashboard JSON."""

        dashboard_title = f"External API Monitoring{title_suffix}"
        if len(providers) == 1:
            dashboard_title = f"{providers[0].get('name', 'Unknown')} API Monitoring{title_suffix}"

        dashboard = {
            "id": self.dashboard_id,
            "uid": f"external-api-{self.dashboard_id}",
            "title": dashboard_title,
            "description": f"Monitoring dashboard for external API providers. Generated on {datetime.now().isoformat()}",
            "tags": ["external-api", "cost-monitoring", "rate-limits", "autogen"],
            "timezone": "browser",
            "refresh": "30s",
            "time": {
                "from": "now-6h",
                "to": "now"
            },
            "timepicker": {
                "refresh_intervals": ["5s", "10s", "30s", "1m", "5m", "15m", "30m", "1h", "2h", "1d"]
            },
            "panels": [],
            "templating": {
                "list": self._generate_template_variables(providers)
            },
            "annotations": {
                "list": []
            },
            "schemaVersion": 36,
            "version": 1,
            "links": []
        }

        # Generate panels based on template
        if template == "comprehensive":
            dashboard["panels"] = self._generate_comprehensive_panels(providers)
        elif template == "cost-focused":
            dashboard["panels"] = self._generate_cost_panels(providers)
        elif template == "performance":
            dashboard["panels"] = self._generate_performance_panels(providers)
        elif template == "rate-limits":
            dashboard["panels"] = self._generate_rate_limit_panels(providers)
        else:
            raise ValueError(f"Unknown template: {template}")

        return dashboard

    def _generate_template_variables(self, providers: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Generate Grafana template variables for provider selection."""
        provider_options = [{"text": p.get("name", p.get("id")), "value": p.get("id")} for p in providers if p.get("id")]

        return [
            {
                "name": "provider",
                "type": "custom",
                "label": "Provider",
                "query": ",".join([opt['value'] for opt in provider_options]),
                "options": provider_options,
                "current": {"text": "All", "value": "$__all"},
                "multi": True,
                "includeAll": True,
                "allValue": ".*"
            },
            {
                "name": "environment",
                "type": "custom",
                "label": "Environment",
                "query": "development,staging,production",
                "options": [
                    {"text": "Development", "value": "development"},
                    {"text": "Staging", "value": "staging"},
                    {"text": "Production", "value": "production"},
                ],
                "current": {"text": "Development", "value": "development"},
                "multi": False,
            }
        ]

    def _generate_comprehensive_panels(self, providers: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Generate comprehensive monitoring panels."""
        panels = []

        # Row 1: Overview stats
        panels.extend(self._generate_overview_row())

        # Row 2: Cost monitoring
        panels.extend(self._generate_cost_panels(providers, start_y=8))

        # Row 3: Rate limits & performance
        panels.extend(self._generate_rate_limit_panels(providers, start_y=16))
        panels.extend(self._generate_performance_panels(providers, start_y=16, start_x=12))

        # Row 4: Error monitoring
        panels.extend(self._generate_error_panels(providers, start_y=24))

        return panels

    def _generate_overview_row(self, start_y: int = 0) -> List[Dict[str, Any]]:
        """Generate overview statistics panels."""
        return [
            {
                "id": self._next_panel_id(),
                "title": "Total API Calls (24h)",
                "type": "stat",
                "gridPos": {"h": 8, "w": 6, "x": 0, "y": start_y},
                "targets": [
                    {
                        "expr": "sum(increase(external_api_call_total{provider=~\"$provider\", environment=~\"$environment\"}[24h]))",
                        "legendFormat": "Total Calls",
                        "refId": "A"
                    }
                ],
                "fieldConfig": {
                    "defaults": {
                        "unit": "short",
                        "color": {"mode": "thresholds"},
                        "thresholds": {
                            "mode": "absolute",
                            "steps": [
                                {"color": "green", "value": None},
                                {"color": "yellow", "value": 1000},
                                {"color": "red", "value": 5000}
                            ]
                        }
                    }
                }
            },
            {
                "id": self._next_panel_id(),
                "title": "Daily Cost Estimate",
                "type": "stat",
                "gridPos": {"h": 8, "w": 6, "x": 6, "y": start_y},
                "targets": [
                    {
                        "expr": "sum(increase(external_api_cost_usd_total{provider=~\"$provider\", environment=~\"$environment\"}[24h]))",
                        "legendFormat": "Cost USD",
                        "refId": "A"
                    }
                ],
                "fieldConfig": {
                    "defaults": {
                        "unit": "currencyUSD",
                        "color": {"mode": "thresholds"},
                        "thresholds": {
                            "mode": "absolute",
                            "steps": [
                                {"color": "green", "value": None},
                                {"color": "yellow", "value": 10},
                                {"color": "red", "value": 50}
                            ]
                        }
                    }
                }
            },
            {
                "id": self._next_panel_id(),
                "title": "Error Rate (24h)",
                "type": "stat",
                "gridPos": {"h": 8, "w": 6, "x": 12, "y": start_y},
                "targets": [
                    {
                        "expr": "sum(rate(external_api_call_total{provider=~\"$provider\", environment=~\"$environment\", status!=\"success\"}[24h])) / sum(rate(external_api_call_total{provider=~\"$provider\", environment=~\"$environment\"}[24h])) * 100",
                        "legendFormat": "Error %",
                        "refId": "A"
                    }
                ],
                "fieldConfig": {
                    "defaults": {
                        "unit": "percent",
                        "color": {"mode": "thresholds"},
                        "thresholds": {
                            "mode": "absolute",
                            "steps": [
                                {"color": "green", "value": None},
                                {"color": "orange", "value": 5},
                                {"color": "red", "value": 15}
                            ]
                        }
                    }
                }
            },
            {
                "id": self._next_panel_id(),
                "title": "Avg Response Time",
                "type": "stat",
                "gridPos": {"h": 8, "w": 6, "x": 18, "y": start_y},
                "targets": [
                    {
                        "expr": "sum(rate(external_api_duration_seconds_sum{provider=~\"$provider\", environment=~\"$environment\", status=\"success\"}[5m])) / sum(rate(external_api_duration_seconds_count{provider=~\"$provider\", environment=~\"$environment\", status=\"success\"}[5m])) * 1000",
                        "legendFormat": "Avg ms",
                        "refId": "A"
                    }
                ],
                "fieldConfig": {
                    "defaults": {
                        "unit": "ms",
                        "color": {"mode": "thresholds"},
                        "thresholds": {
                            "mode": "absolute",
                            "steps": [
                                {"color": "green", "value": None},
                                {"color": "yellow", "value": 1000},
                                {"color": "red", "value": 5000}
                            ]
                        }
                    }
                }
            }
        ]

    def _generate_cost_panels(self, providers: List[Dict[str, Any]], start_y: int = 0) -> List[Dict[str, Any]]:
        """Generate cost monitoring panels."""
        return [
            {
                "id": self._next_panel_id(),
                "title": "Cost Burn Rate by Provider",
                "type": "timeseries",
                "gridPos": {"h": 8, "w": 12, "x": 0, "y": start_y},
                "targets": [
                    {
                        "expr": "sum by (provider) (rate(external_api_cost_usd_total{provider=~\"$provider\", environment=~\"$environment\"}[5m]) * 3600)",
                        "legendFormat": "{{provider}} - $/hour",
                        "refId": "A"
                    }
                ],
                "fieldConfig": {
                    "defaults": {
                        "unit": "currencyUSD",
                        "custom": {"drawStyle": "line", "lineInterpolation": "linear", "fillOpacity": 10, "stacking": {"mode": "normal"}}
                    }
                },
                "options": {
                    "tooltip": {"mode": "multi"},
                    "legend": {"displayMode": "list", "placement": "bottom"}
                }
            },
            {
                "id": self._next_panel_id(),
                "title": "Monthly Budget Projection",
                "type": "bargauge",
                "gridPos": {"h": 8, "w": 12, "x": 12, "y": start_y},
                "targets": [
                    {
                        "expr": "sum by (provider) (increase(external_api_cost_usd_total{provider=~\"$provider\", environment=~\"$environment\"}[24h])) * 30",
                        "legendFormat": "{{provider}}",
                        "refId": "A"
                    }
                ],
                "fieldConfig": {
                    "defaults": {
                        "unit": "currencyUSD",
                        "color": {"mode": "thresholds"},
                        "thresholds": {
                            "mode": "absolute",
                            "steps": [
                                {"color": "green", "value": None},
                                {"color": "yellow", "value": 100},
                                {"color": "red", "value": 250}
                            ]
                        }
                    }
                },
                "options": {
                    "orientation": "horizontal",
                    "displayMode": "lcd"
                }
            }
        ]

    def _generate_rate_limit_panels(self, providers: List[Dict[str, Any]], start_y: int = 0, start_x: int = 0) -> List[Dict[str, Any]]:
        """Generate rate limit monitoring panels."""
        return [
            {
                "id": self._next_panel_id(),
                "title": "Requests per Minute",
                "type": "timeseries",
                "gridPos": {"h": 8, "w": 12, "x": start_x, "y": start_y},
                "targets": [
                    {
                        "expr": "sum by (provider) (rate(external_api_call_total{provider=~\"$provider\", environment=~\"$environment\"}[1m]))",
                        "legendFormat": "{{provider}} - req/sec",
                        "refId": "A"
                    }
                ],
                "fieldConfig": {
                    "defaults": {
                        "unit": "reqps",
                        "custom": {"drawStyle": "bar", "fillOpacity": 70},
                        "color": {"mode": "palette-classic"}
                    }
                },
                "options": {
                    "tooltip": {"mode": "multi"},
                    "legend": {"displayMode": "list", "placement": "bottom"}
                }
            }
        ]

    def _generate_performance_panels(self, providers: List[Dict[str, Any]], start_y: int = 0, start_x: int = 0) -> List[Dict[str, Any]]:
        """Generate performance monitoring panels."""
        return [
            {
                "id": self._next_panel_id(),
                "title": "Response Time Distribution (p50, p95, p99)",
                "type": "timeseries",
                "gridPos": {"h": 8, "w": 12, "x": start_x, "y": start_y},
                "targets": [
                    {
                        "expr": "histogram_quantile(0.50, sum(rate(external_api_duration_seconds_bucket{provider=~\"$provider\", environment=~\"$environment\"}[5m])) by (le, provider)) * 1000",
                        "legendFormat": "{{provider}} - p50",
                        "refId": "A"
                    },
                    {
                        "expr": "histogram_quantile(0.95, sum(rate(external_api_duration_seconds_bucket{provider=~\"$provider\", environment=~\"$environment\"}[5m])) by (le, provider)) * 1000",
                        "legendFormat": "{{provider}} - p95",
                        "refId": "B"
                    },
                    {
                        "expr": "histogram_quantile(0.99, sum(rate(external_api_duration_seconds_bucket{provider=~\"$provider\", environment=~\"$environment\"}[5m])) by (le, provider)) * 1000",
                        "legendFormat": "{{provider}} - p99",
                        "refId": "C"
                    }
                ],
                "fieldConfig": {
                    "defaults": {
                        "unit": "ms",
                        "custom": {"drawStyle": "line", "fillOpacity": 0},
                        "color": {"mode": "palette-classic"}
                    }
                }
            }
        ]

    def _generate_error_panels(self, providers: List[Dict[str, Any]], start_y: int = 0) -> List[Dict[str, Any]]:
        """Generate error monitoring panels."""
        return [
            {
                "id": self._next_panel_id(),
                "title": "Error Rate by Provider",
                "type": "timeseries",
                "gridPos": {"h": 8, "w": 12, "x": 0, "y": start_y},
                "targets": [
                    {
                        "expr": "sum by (provider, status) (rate(external_api_call_total{provider=~\"$provider\", environment=~\"$environment\", status!=\"success\"}[5m]))",
                        "legendFormat": "{{provider}} - {{status}} errors/sec",
                        "refId": "A"
                    }
                ],
                "fieldConfig": {
                    "defaults": {
                        "unit": "reqps",
                        "custom": {"drawStyle": "bar", "stacking": {"mode": "normal"}},
                        "color": {"mode": "palette-classic"}
                    }
                }
            },
            {
                "id": self._next_panel_id(),
                "title": "Status Code Distribution (24h)",
                "type": "piechart",
                "gridPos": {"h": 8, "w": 12, "x": 12, "y": start_y},
                "targets": [
                    {
                        "expr": "sum by (status) (increase(external_api_call_total{provider=~\"$provider\", environment=~\"$environment\"}[24h]))",
                        "legendFormat": "{{status}}",
                        "refId": "A"
                    }
                ],
                "options": {
                    "legend": {"displayMode": "table", "placement": "right"},
                    "pieType": "donut"
                }
            }
        ]

    def _next_panel_id(self) -> int:
        """Get next panel ID."""
        panel_id = self.panel_id_counter
        self.panel_id_counter += 1
        return panel_id

def load_providers_from_registry() -> List[Dict[str, Any]]:
    """Load providers from the registry.yaml file."""
    try:
        if get_providers_by_category:
            # Use the backend function if available
            return get_providers_by_category("api") or []
        else:
            # Fallback to reading registry directly
            registry_path = Path(__file__).parent.parent / "backend" / "providers" / "registry.yaml"
            if registry_path.exists():
                with open(registry_path, 'r') as f:
                    registry = yaml.safe_load(f)
                    return registry.get("providers", [])
            else:
                logger.warning(f"Registry file not found at {registry_path}")
                return []
    except Exception as e:
        logger.error(f"Error loading providers: {e}")
        return []

def save_dashboard(dashboard: Dict[str, Any], output_path: str) -> None:
    """Save dashboard JSON to file."""
    output_file = Path(output_path)
    output_file.parent.mkdir(parents=True, exist_ok=True)

    with open(output_file, 'w') as f:
        json.dump(dashboard, f, indent=2, sort_keys=False)

    logger.info(f"Dashboard saved to {output_file}")
    logger.info(f"Import into Grafana: Dashboards > New > Import > Upload JSON file")

def generate_provider_specific_dashboards(providers: List[Dict[str, Any]], template: str, output_dir: str) -> None:
    """Generate individual dashboards for each provider."""
    output_dir_path = Path(output_dir)
    output_dir_path.mkdir(parents=True, exist_ok=True)

    for provider in providers:
        provider_id = provider.get("id", "unknown")
        generator = GrafanaDashboardGenerator() # Re-init to reset panel IDs for each dashboard
        dashboard = generator.generate_dashboard(
            [provider],
            template=template,
        )

        output_path = output_dir_path / f"{provider_id}_dashboard.json"
        save_dashboard(dashboard, str(output_path))

def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description="Generate Grafana dashboards for external API monitoring")
    parser.add_argument("--provider", help="Generate dashboard for specific provider only")
    parser.add_argument("--template", choices=list(DASHBOARD_TEMPLATES.keys()),
                       default="comprehensive", help="Dashboard template to use")
    parser.add_argument("--output", default="grafana_dashboards/external_api_dashboard.json",
                       help="Output file path for the main dashboard")
    parser.add_argument("--output-dir", default="grafana_dashboards",
                       help="Directory for provider-specific dashboards")
    parser.add_argument("--individual", action="store_true",
                       help="Generate individual dashboards for each provider in addition to the main one")
    parser.add_argument("--list-templates", action="store_true",
                       help="List available dashboard templates")

    args = parser.parse_args()

    if args.list_templates:
        print("Available dashboard templates:")
        for template, description in DASHBOARD_TEMPLATES.items():
            print(f"  {template}: {description}")
        return

    # Load providers
    all_providers = load_providers_from_registry()
    if not all_providers:
        logger.error("No providers found in registry")
        return 1

    # Filter providers if specified
    if args.provider:
        providers_to_generate = [p for p in all_providers if p.get("id") == args.provider]
        if not providers_to_generate:
            logger.error(f"Provider '{args.provider}' not found")
            return 1
    else:
        providers_to_generate = all_providers

    logger.info(f"Generating dashboard(s) for: {[p.get('id') for p in providers_to_generate]}")
    logger.info(f"Using template: {args.template}")

    # Generate main/combined dashboard
    generator = GrafanaDashboardGenerator()
    dashboard = generator.generate_dashboard(providers_to_generate, template=args.template)
    save_dashboard(dashboard, args.output)

    # Generate individual provider dashboards if requested
    if args.individual:
        logger.info(f"Generating individual dashboards in {args.output_dir}")
        generate_provider_specific_dashboards(providers_to_generate, args.template, args.output_dir)

    print(f"\nðŸŽ‰ Dashboard generation complete!")
    print(f"ðŸ“Š Generated for providers: {', '.join(p.get('name', p.get('id')) for p in providers_to_generate)}")
    print(f"ðŸ“ Main dashboard: {args.output}")
    if args.individual:
        print(f"ðŸ“ Individual dashboards: {args.output_dir}")
    print(f"\nðŸ“‹ Import instructions:")
    print(f"   1. Open Grafana")
    print(f"   2. Navigate to Dashboards")
    print(f"   3. Click 'New' -> 'Import'")
    print(f"   4. Upload the generated JSON file(s)")
    print(f"   5. Select your Prometheus data source")

    return 0

if __name__ == "__main__":
    sys.exit(main())
